# 常用的高效排序算法

## 1.快速排序（Quick Sort）

由Tony Hoare在1960年提出的一种排序算法，它是一种非常高效的排序方法，广泛用于各类编程环境。快速排序使用分治法（Divide and Conquer）策略来把一个序列分为两个子序列，具体步骤如下：

### 步骤

1. **选择基准值（Pivot Selection）**：
   快速排序首先从数组中选择一个元素作为基准值，此元素称为“pivot”。基准的选择可以有多种方式，比如始终选择第一个元素或最后一个元素，或者随机选择，或者取中值等。基准值的好坏直接影响到快速排序的效率。
2. **分区操作（Partitioning）**：
   数组被重新排列，所有比基准值小的元素都移动到基准的左边，所有比基准值大的元素都移动到基准的右边。这个操作完成后，基准值位于其最终位置。这一步实际上是在数组内部进行，所以它的空间复杂度是很低的。
3. **递归排序子数组（Recursively sort sub-arrays）**：
   递归地将左边子数组和右边子数组进行排序，递归的终止条件是序列的长度为0或1，这时候序列已经被排序。12

### 性能

- **最佳情况**：当基准选择使得每次分区都将列表均等分时，时间复杂度为 𝑂(𝑛log⁡𝑛)。
- **最坏情况**：当基准选择导致一边的分区包含0个元素，另一边包含n-1个元素，此时时间复杂度为 𝑂(𝑛2)。比如数组已经有序或逆序。
- **平均情况**：即使在平均条件下，时间复杂度也是 𝑂(𝑛log⁡𝑛)。

### 空间复杂度

- 快速排序的空间复杂度为 𝑂(log⁡𝑛)，这是因为快速排序是递归的，需要栈空间来存储递归调用的信息。

- 尽管快速排序在平均情况下非常高效，但在最坏的情况下它的性能可能不如其他 𝑂(𝑛log⁡𝑛)的排序算法，如归并排序。因此，在对效率要求极高的场景中，可能会选择其他更为稳定的算法，或者优化快速排序的基准选择和实现方式（如使用随机化快速排序或三数取中法来选择基准）。

  

## Demo

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr.pop()
        greater = []
        lesser = []
        for element in arr:
            if element > pivot:
                greater.append(element)
            else:
                lesser.append(element)
        return quick_sort(lesser) + [pivot] + quick_sort(greater)

example_array = [10, 7, 8, 9, 1, 5]
sorted_array = quick_sort(example_array)
print("Sorted array:", sorted_array)
```



## 2. 归并排序

归并排序（Merge Sort）是一种采用分而治之策略的有效排序算法，由约翰·冯·诺伊曼在1945年提出。这种算法通过递归地将数据分成更小的片段来进行排序，然后再将这些已排序的片段合并成完整的有序列表。归并排序是稳定的排序方法，广泛应用于不同的应用场景，尤其是在数据量大或数据不在内存中（如外部排序）的情况下。

### 基本原理

归并排序的基本操作包括两个主要步骤：分割和合并。

1. **分割**：将待排序的数组不断地分割成两半，直到每个小组只有一个元素或没有元素。
2. **合并**：逐步将小组合并成较大的组，同时保持元素的顺序，直至重新组合成一个完整的有序数组。

### 算法过程

归并排序的过程可以分为递归分割和合并两个阶段：

- **递归分割**：原始数组被递归地分割成越来越小的半子表，直到每个子表只有一个元素。
- **合并操作**：将每个有序的子表逐步合并成原始数组的大小。在合并过程中，会需要额外的空间来存储临时数组，以便将两个有序数组合并成一个有序数组。

### 时间复杂度

- **最好、最坏和平均情况**：归并排序的时间复杂度在所有情况下都是 𝑂(𝑛log⁡𝑛)。这是因为无论如何数组都需要完全分割并重新合并。

### 空间复杂度

- 归并排序需要额外的存储空间，其空间复杂度为 𝑂(𝑛)，这是用来存储在合并过程中的临时数组。

### 优点与缺点

- **优点**：
  - 时间复杂度稳定，适合于大数据量的排序。
  - 是一个稳定的排序算法，不会改变相同元素之间的相对顺序。
  - 特别适合于链表类型的数据结构，可以实现 O(1) 的空间复杂度。
- **缺点**：
  - 需要额外的存储空间，尤其在内存使用受限的设备上可能是一个缺点。
  - 在小数据集上，相比如插入排序等简单排序算法，可能不够高效。

### Demo

```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2  # 找到中点，进行分割
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)  # 递归排序左半部分
        merge_sort(right_half)  # 递归排序右半部分

        i = j = k = 0

        # 合并过程
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

arr = [10, 7, 8, 9, 1, 5]
merge_sort(arr)
print("Sorted array is:", arr)
```

## 3. 堆排序

堆排序（Heap Sort）是一种基于堆数据结构的比较排序算法。它利用了二叉堆的性质来进行排序，其中最常用的是二叉最大堆，确保父节点的值总是大于或等于其子节点的值。堆排序的主要优势在于其高效的时间复杂度和原地排序的特性。

### 基本概念

#### 二叉堆

二叉堆是一种特殊的完全二叉树，可以分为最大堆和最小堆：

- **最大堆**：每个节点的值都大于或等于其子节点的值。
- **最小堆**：每个节点的值都小于或等于其子节点的值。

在堆排序中，我们通常使用最大堆来对元素进行降序排序，或者使用最小堆进行升序排序。

### 堆排序过程

堆排序可以分为两个主要阶段：建堆（Build Heap）和排序（Sort）。

#### 1. 建堆（Build Heap）

将无序的输入数组构造成一个最大堆。这一步保证了堆的根节点是所有元素中的最大值。

#### 2. 排序（Sort）

- 将根节点（即当前最大值）与堆的最后一个元素交换。
- 缩减堆的大小，排除当前最大元素，确保它不会在后续操作中被修改。
- 重新调整新的根节点的位置，维持最大堆的特性。
- 重复这个过程，直到堆的大小为1，此时数组已经完全排序。

### 时间复杂度

- **最好、最坏和平均情况**：堆排序的时间复杂度都是 𝑂(𝑛log⁡𝑛)，其中 𝑛*n* 是数组中的元素数量。

### 空间复杂度

- 堆排序是一个原地排序算法，其空间复杂度为 𝑂(1)。

### 优点与缺点

- **优点**：
  - 时间复杂度稳定为 𝑂(𝑛log⁡𝑛)*O*(*n*log*n*)，适合处理大数据集。
  - 原地排序，不需要额外的存储空间。
- **缺点**：
  - 相较于其他 𝑂(𝑛log⁡𝑛)*O*(*n*log*n*) 排序算法如快速排序和归并排序，堆排序的实际运行时间常常较慢，因为其操作包括较多的元素比较和交换。
  - 不稳定排序，相同元素的相对顺序可能在排序后发生改变。

## Demo

```python
def heapify(arr, n, i):
    largest = i  # 初始化最大为根
    left = 2 * i + 1  # 左 = 2*i + 1
    right = 2 * i + 2  # 右 = 2*i + 2

    # 查看左子节点是否存在且大于根
    if left < n and arr[largest] < arr[left]:
        largest = left

    # 查看右子节点是否存在且大于根
    if right < n and arr[largest] < arr[right]:
        largest = right

    # 如果最大不是根，交换它
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # 交换

        # 递归地堆化受影响的子树
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # 建立最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 一个个从堆顶取出元素
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 交换
        heapify(arr, i, 0)


arr = [10, 7, 8, 9, 1, 5]
heap_sort(arr)
print("Sorted array is:", arr)
```

# 小总结

### 1. 冒泡排序（Bubble Sort）

- **基本原理**：通过重复遍历待排序列表，比较相邻元素，如果顺序错误就交换它们，直到没有需要交换的元素为止。
- **时间复杂度**：平均和最坏情况为 𝑂(𝑛2)，最好情况为 𝑂(𝑛)。
- **空间复杂度**：𝑂(1)
- **特点**：简单，但效率低，适用于小数据集。

### 2. 选择排序（Selection Sort）

- **基本原理**：不断选择剩余元素中的最小（或最大）者，放到已排序序列的末尾。
- **时间复杂度**：始终为 𝑂(𝑛2)
- **空间复杂度**：𝑂(1)
- **特点**：不稳定，简单，但通常比冒泡排序性能稍好。

### 3. 插入排序（Insertion Sort）

- **基本原理**：构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- **时间复杂度**：平均和最坏情况为 𝑂(𝑛2)，最好情况为 𝑂(𝑛)。
- **空间复杂度**：𝑂(1)
- **特点**：稳定，适合小规模数据或基本有序的数据。

### 4. 快速排序（Quick Sort）

- **基本原理**：选择一个基准元素，通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序。
- **时间复杂度**：平均为 𝑂(𝑛log⁡𝑛)，最坏为 𝑂(𝑛2)，但通过合理选择基准可以避免最坏情况。
- **空间复杂度**：𝑂(log⁡𝑛)（递归调用栈的空间）
- **特点**：非常高效，不稳定，适用于大数据集。

### 5. 归并排序（Merge Sort）



### 6. 堆排序（Heap Sort）



### 7. 计数排序（Counting Sort）

- **基本原理**：对每一个输入的元素 𝑥，确定小于 𝑥的元素个数，利用这一信息直接把 𝑥放到最终的位置上。
- **时间复杂度**：𝑂(𝑛+𝑘)，其中 k 是数据范围。
- **空间复杂度**：𝑂(𝑘)，需要额外的空间存储计数数组。
- **特点**：非比较排序，适用于数据范围小且明确的情况。

### 8. 桶排序（Bucket Sort）

- **基本原理**：将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是递归桶排序）。
- **时间复杂度**：平均 𝑂(𝑛+𝑘)，最坏 𝑂(𝑛2)。
- **空间复杂度**：𝑂(𝑛+𝑘)
- **特点**：适用于数据分布均匀的情况。

### 9. 基数排序（Radix Sort）

- **基本原理**：按照低位先排序，然后收集；再按高位排序，然后再收集，依次类推，直到最高位。有时也用“桶排序”或“计数排序”作为子过程。
- **时间复杂度**：𝑂(𝑛𝑘)，其中 𝑘 是数字位数。
- **空间复杂度**：𝑂(𝑛+𝑘)
- **特点**：非比较排序，适合于处理大量数字或字符串，特别是当 𝑘（位数或范围）不大时效率高。

### 10. 希尔排序（Shell Sort）

- **基本原理**：是插入排序的一种更高效的改进版本。它通过将原始列表分割成多个子列表，每个子列表使用插入排序进行排序。
- **时间复杂度**：取决于所选的间隔序列，最坏情况可以达到 𝑂(𝑛2)，但某些间隔序列可以达到 𝑂(𝑛1.5) 或更好。
- **空间复杂度**：𝑂(1)
- **特点**：不稳定，性能优于简单插入排序，尤其适合中等大小的数组。
## 学习链接：

1. https://zhuanlan.zhihu.com/p/365698607
2. https://blog.csdn.net/lijunhcn/article/details/132408647

# 动态规划（Dynamic Programming，DP）

动态规划算法的核心思想基于两个主要概念：**重叠子问题**和**最优子结构**。通过这两个概念，动态规划解决复杂问题的效率得以显著提高。下面详细介绍这两个概念：

### 重叠子问题（Overlapping Subproblems）

在解决某些问题时，同一个小问题会在计算过程中多次出现。如果我们每次遇到这样的子问题都重新计算，明显会增加计算的时间和复杂性。动态规划算法通过存储这些子问题的解（通常在一个数组或哈希表中），使得每个子问题只被解决一次，从而节省计算资源。例如，在计算斐波那契数列时，直接递归会导致大量的重复计算，而动态规划通过保存已计算的结果避免了这种重复。

### 最优子结构（Optimal Substructure）

一个问题的最优解包含其子问题的最优解。这意味着可以通过组合子问题的解来构造整个问题的解。在动态规划中，我们依赖于这种性质来构建解决方案。通过解决所有相关的子问题，可以确保找到问题的最优解。例如，在求解背包问题时，我们会考虑每个物品是否放入背包，并基于子问题的最优解来决定。

### 动态规划的实施步骤

动态规划通常按照以下步骤进行：

1. **定义子问题**：将原问题分解成更小的子问题。
2. **初始化条件**：确定最基本的子问题的解，这些通常是递归算法的终止条件。
3. **构建动态规划表**：使用一个表（通常是数组或二维数组）来保存每个子问题的解。
4. **填表顺序**：确定填表的顺序，确保解决一个子问题时所需的所有相关子问题已经被解决。
5. **转移方程**：根据问题的性质，设计一个方程（或多个方程）来描述如何从子问题的解得到更大问题的解。
6. **构建解**：根据填表得到的结果构建最终的解答。

动态规划不仅仅是一个算法，而是一种算法设计方法，它使得解决复杂问题变得更加系统化和高效。通过明确地定义子问题、存储中间结果以及递推地构建最终解，动态规划能够有效地解决各种优化问题。



以计算斐波那契数列为例，斐波那契数列是一个经典的递归问题，其中每个数字是前两个数字的和，定义如下：

- F(0) = 0
- F(1) = 1
- 对于 n ≥ 2，F(n) = F(n-1) + F(n-2)

### 递归方法

一种直观的方法是使用递归直接根据定义计算斐波那契数列：

```python
def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
```

这种方法简单直观，但效率低下，因为它重复计算了许多子问题（如 F(n-2) 在计算 F(n) 和 F(n-1) 时都被计算了两次）。

### 动态规划方法

为了优化上述递归方法，我们可以使用动态规划的技术，具体步骤如下：

1. **初始化**：创建一个数组 `dp`，其中 `dp[i]` 用于存储第 `i` 个斐波那契数。
2. **基本情况赋值**：设定 `dp[0] = 0` 和 `dp[1] = 1`。
3. **迭代计算**：对于所有 `i` 从 2 到 `n`，计算 `dp[i] = dp[i-1] + dp[i-2]`。

```python
def fibonacci_dp(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

这种方法的时间复杂度为 O(n)，而且由于每个子问题只计算一次且结果被存储起来，避免了重复计算，大大提高了效率。

### 动态规划的优势和局限

**优势**：

- **高效**：避免了重复计算，减少了不必要的计算量。
- **直观**：逐步解决问题，易于理解和实现。

**局限**：

- **空间消耗**：尽管可以通过各种技巧（如使用有限变量代替数组）减少空间消耗，但在某些情况下仍然需要额外的存储空间。